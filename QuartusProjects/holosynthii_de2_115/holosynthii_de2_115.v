
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module holosynthii_de2_115(

    //////////// CLOCK //////////
    CLOCK_50,
    CLOCK2_50,
    CLOCK3_50,

	//////////// Sma //////////
	SMA_CLKIN,
	SMA_CLKOUT,

    //////////// LED //////////
    LEDG,
    LEDR,

    //////////// KEY //////////
    KEY,

    //////////// SW //////////
    SW,

    //////////// SEG7 //////////
    HEX0,
    HEX1,
    HEX2,
    HEX3,
    HEX4,
    HEX5,
    HEX6,
    HEX7,

    //////////// RS232 //////////
    UART_CTS,
    UART_RTS,
    UART_RXD,
    UART_TXD,

    //////////// SDCARD //////////
    SD_CLK,
    SD_CMD,
    SD_DAT,
    SD_WP_N,

    //////////// VGA //////////
    VGA_B,
    VGA_BLANK_N,
    VGA_CLK,
    VGA_G,
    VGA_HS,
    VGA_R,
    VGA_SYNC_N,
    VGA_VS,

    //////////// Audio //////////
    AUD_ADCDAT,
    AUD_ADCLRCK,
    AUD_BCLK,
    AUD_DACDAT,
    AUD_DACLRCK,
    AUD_XCK,

    //////////// I2C for Audio HSMC  //////////
    I2C_SCLK,
    I2C_SDAT,

    //////// SDRAM //////////
    DRAM_ADDR,
    DRAM_BA,
    DRAM_CAS_N,
    DRAM_CKE,
    DRAM_CLK,
    DRAM_CS_N,
    DRAM_DQ,
    DRAM_DQM,
    DRAM_RAS_N,
    DRAM_WE_N,

    //////////// SRAM //////////
    SRAM_ADDR,
    SRAM_CE_N,
    SRAM_DQ,
    SRAM_LB_N,
    SRAM_OE_N,
    SRAM_UB_N,
    SRAM_WE_N,

    //////////// Flash //////////
    FL_ADDR,
    FL_CE_N,
    FL_DQ,
    FL_OE_N,
    FL_RST_N,
    FL_RY,
    FL_WE_N,
    FL_WP_N,

    ///EPCS
    DCLK,
    DATA0,
    ASDO,
    nCSO,

    //////////// GPIO, GPIO connect to LTM - 4.3" LCD and Touch //////////
    LTM_ADC_BUSY,
    LTM_ADC_DCLK,
    LTM_ADC_DIN,
    LTM_ADC_DOUT,
    LTM_ADC_PENIRQ_n,
    LTM_B,
    LTM_DEN,
    LTM_G,
    LTM_GREST,
    LTM_HD,
    LTM_NCLK,
    LTM_R,
    LTM_SCEN,
    LTM_SDA,
    LTM_VD,
	
	//////////// HSMC, HSMC connect to HSMC Default //////////
	HSMC_CLKIN_N1,
	HSMC_CLKIN_N2,
	HSMC_CLKIN_P1,
	HSMC_CLKIN_P2,
	HSMC_CLKIN0,
	HSMC_CLKOUT_N1,
	HSMC_CLKOUT_N2,
	HSMC_CLKOUT_P1,
	HSMC_CLKOUT_P2,
	HSMC_CLKOUT0,
	HSMC_D,
	HSMC_RX_D_N,
	HSMC_RX_D_P,
	HSMC_TX_D_N,
	HSMC_TX_D_P 

);

//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input                       CLOCK_50;
input                       CLOCK2_50;
input                       CLOCK3_50;

//////////// Sma //////////
input		          		SMA_CLKIN;
output		          		SMA_CLKOUT;

//////////// LED //////////
output           [8:0]      LEDG;
output          [17:0]      LEDR;

//////////// KEY //////////
input            [3:0]      KEY;

//////////// SW //////////
input           [17:0]      SW;

//////////// SEG7 //////////
output           [6:0]      HEX0;
output           [6:0]      HEX1;
output           [6:0]      HEX2;
output           [6:0]      HEX3;
output           [6:0]      HEX4;
output           [6:0]      HEX5;
output           [6:0]      HEX6;
output           [6:0]      HEX7;

//////////// RS232 //////////
output                      UART_CTS;
input                       UART_RTS;
input                       UART_RXD;
output                      UART_TXD;

//////////// SDCARD //////////
output                      SD_CLK;
inout                       SD_CMD;
inout            [3:0]      SD_DAT;
input                       SD_WP_N;

//////////// VGA //////////
output           [7:0]      VGA_B;
output                      VGA_BLANK_N;
output                      VGA_CLK;
output           [7:0]      VGA_G;
output                      VGA_HS;
output           [7:0]      VGA_R;
output                      VGA_SYNC_N;
output                      VGA_VS;

//////////// Audio //////////
input                       AUD_ADCDAT;
inout                       AUD_ADCLRCK;
inout                       AUD_BCLK;
output                      AUD_DACDAT;
inout                       AUD_DACLRCK;
output                      AUD_XCK;

//////////// I2C for Audio HSMC  //////////
output                      I2C_SCLK;
inout                       I2C_SDAT;

//////////// SDRAM //////////
output          [12:0]      DRAM_ADDR;
output           [1:0]      DRAM_BA;
output                      DRAM_CAS_N;
output                      DRAM_CKE;
output                      DRAM_CLK;
output                      DRAM_CS_N;
inout           [31:0]      DRAM_DQ;
output           [3:0]      DRAM_DQM;
output                      DRAM_RAS_N;
output                      DRAM_WE_N;

//////////// SRAM //////////
output          [19:0]      SRAM_ADDR;
output                      SRAM_CE_N;
inout           [15:0]      SRAM_DQ;
output                      SRAM_LB_N;
output                      SRAM_OE_N;
output                      SRAM_UB_N;
output                      SRAM_WE_N;

//////////// Flash //////////
output          [22:0]      FL_ADDR;
output                      FL_CE_N;
inout            [7:0]      FL_DQ;
output                      FL_OE_N;
output                      FL_RST_N;
input                       FL_RY;
output                      FL_WE_N;
output                      FL_WP_N;

////EPCS
output                   DCLK;
input                    DATA0;
output                   ASDO;
output                   nCSO;

//////////// GPIO, GPIO connect to LTM - 4.3" LCD and Touch //////////
input                       LTM_ADC_BUSY;
output                      LTM_ADC_DCLK;
output                      LTM_ADC_DIN;
input                       LTM_ADC_DOUT;
input                       LTM_ADC_PENIRQ_n;
output           [7:0]      LTM_B;
output                      LTM_DEN;
output           [7:0]      LTM_G;
output                      LTM_GREST;
output                      LTM_HD;
output                      LTM_NCLK;
output           [7:0]      LTM_R;
output                      LTM_SCEN;
inout                       LTM_SDA;
output                      LTM_VD;

//////////// HSMC, HSMC connect to HSMC Default //////////
input		          		HSMC_CLKIN_N1;
input		          		HSMC_CLKIN_N2;
input		          		HSMC_CLKIN_P1;
input		          		HSMC_CLKIN_P2;
input		          		HSMC_CLKIN0;
output		          		HSMC_CLKOUT_N1;
output		          		HSMC_CLKOUT_N2;
output		          		HSMC_CLKOUT_P1;
output		          		HSMC_CLKOUT_P2;
output		          		HSMC_CLKOUT0;
inout		     [3:0]		HSMC_D;
inout		    [16:0]		HSMC_RX_D_N;
inout		    [16:0]		HSMC_RX_D_P;
inout		    [16:0]		HSMC_TX_D_N;
inout		    [16:0]		HSMC_TX_D_P;

//=======================================================
//  PARAMETER declarations
//=======================================================
`define _Synth
//`define _24BitAudio // if not defined defaults to 16-bit audio output
//`define _271MhzOscs // if not defined defaults to 180 Mhz oscilator clock
//`define _Graphics

//`define _VEEK_Graphics
//`define _LTM_Graphics

//parameter VOICES = 256;
//parameter VOICES = 128;
//parameter VOICES = 64;
//parameter VOICES = 32;
parameter VOICES = 16;
//parameter VOICES = 8;	// number of simultainious voices 
//parameter VOICES = 4;	// number of simultainious voices
//parameter VOICES = 2;	// number of simultainious voices
//parameter VOICES = 1;	// number of simultainious voices

parameter V_OSC = 8;  //!NEEK
//parameter V_OSC = 6;
//parameter V_OSC = 4;	// number of oscilators pr. voice.
//parameter V_OSC = 3;
//parameter V_OSC = 2;	// number of oscilators pr. voice.
//parameter V_OSC = 1;

parameter O_ENVS = 2;	// number of envelope generators pr. oscilator.

parameter V_ENVS = V_OSC * O_ENVS;	// number of envelope generators  pr. voice.

//=======================================================
//  REG/WIRE declarations
//=======================================================

//wire N_save_sig,N_load_sig;
//wire [1:0]N_adr_data_rdy; // 2'b01 = read from synth/save to disk; 2'b11 = write to synth/load from disk 

//wire [7:0]N_sound_nr;
//wire [9:0]N_adr;

//wire [7:0]N_synth_out_data;
//wire [7:0]N_synth_in_data;

//wire [5:0]LCD_R = VGA_R[7:2]; 
//wire [5:0]LCD_G = VGA_G[7:2]; 
//wire [5:0]LCD_B = VGA_B[7:2]; 

//wire [9:0]VGA_R_w,VGA_G_w,VGA_B_w;
assign HSMC_TX_D_P[12] = AUD_XCK; // HSMC_TX_D_P12 		Violet
	
//	assign aud_bck = AUD_BCLK;
	assign HSMC_TX_D_N[11] = AUD_BCLK; // HSMC_TX_D_N11		Orange

//	assign aud_lrck = AUD_DACLRCK;
	assign HSMC_TX_D_P[11] = AUD_DACLRCK; // HSMC_TX_D_P11	Green
		
	assign HSMC_TX_D_N[10] = AUD_DACDAT; // HSMC_TX_D_N10 	White

	
	
	assign clkout_sma = AUD_XCK;
	


reg [7:0]   delay_1;

//wire reset_n,iRST_n;
wire iRST_n;

wire midi_txd;
wire midi_rxd;

//assign midi_rxd = SW[0] ? ~UART_RXD : HSMC_RX_D_P[10]; // Blue

assign midi_rxd = SW[0] ? ~UART_RXD : SW[1] ? HSMC_RX_D_P[10] : ~HSMC_RX_D_P[10]; // Blue

//wire hsmc_midi_in;
//assign hsmc_midi_in = SW[1] ? HSMC_RX_D_P[10] : ~HSMC_RX_D_P[10];  
//assign midi_rxd 	= SW[0] ? ~UART_RXD : hsmc_midi_in; // Blue inverted due to hc04 hex inverter

assign UART_TXD = ~midi_txd; // output midi transmit signal (inverted due to inverter in rs232 chip)
assign HSMC_RX_D_N[9] = ~midi_txd;  // Yellow 

assign SMA_CLKOUT = AUD_XCK;

//assign  FL_RST_N = 1'b1;
//assign  FL_WP_N = 1'b1;


//=======================================================
//  Structural coding
//=======================================================

//assign VGA_R = VGA_R_w[9:2];
//assign VGA_G = VGA_G_w[9:2];
//assign VGA_B = VGA_B_w[9:2];


//assign LTM_R = VGA_R;
//assign LTM_G = VGA_G;
//assign LTM_B = VGA_B;

//assign  LTM_GREST         = KEY[0];
//assign  LTM_GREST       = 1'b0;
//assign  LCD_DIM     = 1'b1;

//assign LTM_NCLK = VGA_CLK;
//assign LCD_NCLK = VGA_CLK;


//assign reset_n = iRST_n;

`ifdef _Nios
    nios_2 u0 (
        .reset_reset_n                                  (KEY[3]),                                  //  reset_0.reset_n
        .clk_clk                                        (CLOCK_50),                                        //    clk_0.clk
        .flash_write_n_to_the_cfi_flash      (FL_WE_N),      //    flash.flash_tristate_controller_tcm_write_n
        .flash_tri_state_bridge_flash_address      (FL_ADDR),      //         .flash_tristate_controller_tcm_address
        .flash_read_n_to_the_cfi_flash       (FL_OE_N),       //         .flash_tristate_controller_tcm_read_n
        .flash_tri_state_bridge_flash_data         (FL_DQ),         //         .flash_tristate_controller_tcm_data
        .flash_select_n_to_the_cfi_flash (FL_CE_N),  //         .flash_tristate_controller_tcm_chipselect_n
        .sd_controller_cs_n                                     (SD_DAT[3]),                                     //  sd_card.cs_n
        .sd_controller_data_out                                 (SD_CMD),                                 //         .data_out
        .sd_controller_data_in                                  (SD_DAT[0]),                                  //         .data_in
        .sd_controller_clk                                      (SD_CLK),                                      //         .clk
        .sram_LB_n                                        (SRAM_LB_N),                                        //     sram.LB_n
        .sram_ADDR                                        (SRAM_ADDR),                                        //         .ADDR
        .sram_DQ                                          (SRAM_DQ),                                          //         .DQ
        .sram_WE_n                                        (SRAM_WE_N),                                        //         .WE_n
        .sram_UB_n                                        (SRAM_UB_N),                                        //         .UB_n
        .sram_OE_n                                        (SRAM_OE_N),                                        //         .OE_n
        .sram_CE_n                                        (SRAM_CE_N),                                         //         .CE_n
         .n_adr_dat_rdy_export                           (N_adr_data_rdy),      // output
        .n_adr_export                                       (N_adr),                //  output    n_synth_adr.output
        .n_synth_out_data_export                            (N_synth_out_data),     //  input   n_synth_out_data.input
        .n_irq_export                                       ( N_irq ),          //  input n_irq.input
        .n_synth_sound_num_export                           ( N_sound_nr ),      // input  n_sound_nr.input
        .n_synth_in_data_export                             (N_synth_in_data),  //  output  n_synth_in_data.export
         .button_export                                 (KEY),          //       
       .altpll_0_areset_export                              (1'b0),                       //   altpll_0_areset.export
                       // the_sdram
       .sdram_wire_addr(DRAM_ADDR),
       .sdram_wire_ba(DRAM_BA),
       .sdram_wire_cas_n(DRAM_CAS_N),
       .sdram_wire_cke(DRAM_CKE),
       .sdram_wire_cs_n(DRAM_CS_N),
       .sdram_wire_dq(DRAM_DQ),
       .sdram_wire_dqm(DRAM_DQM),
       .sdram_wire_ras_n(DRAM_RAS_N),
       .sdram_wire_we_n(DRAM_WE_N),
       .sdram_clk (DRAM_CLK),                             //             sdram.clk
       .ecps_dclk                            (DCLK),                            //                       ecps.dclk
       .ecps_sce                             (nCSO),                             //                           .sce
       .ecps_sdo                             (ASDO),                             //                           .sdo
       .ecps_data0                           (DATA0)                            //                           .data0

         
 );
`endif

//    wire[1:0] N_irq;
//    assign N_irq[0] = N_save_sig;
//    assign N_irq[1] = N_load_sig;
    
synthesizer #(.VOICES(VOICES),.V_OSC(V_OSC),.V_ENVS(V_ENVS)) synthesizer_inst(
	.EXT_CLOCK_IN			(CLOCK_50) ,   // input  CLOCK_50_sig
	.reg_DLY0				(iRST_n),
	.MIDI_Rx_DAT			(midi_rxd) ,    // input  MIDI_DAT_sig (inverted due to inverter in rs232 chip)
	.midi_txd 				( midi_txd ),		// output midi transmit signal (inverted due to inverter in rs232 chip)
	.button					( KEY[3:0] ),            //  Button[3:0]
//    .SW ( SW[17:0]),
    .GLED(LEDG),                            //  Green LED [4:1]
    .RLED(LEDR),                            //  Green LED [4:1]
//  .hex_disp(hex_disp),
`ifdef _Nios
	.N_adr_data_rdy(N_adr_data_rdy) ,   // input  N_ctrl_sig
	.N_adr(N_adr) , // input [9:0] N_synth_num_sig
	.N_synth_out_data(N_synth_out_data),    // output [7:0] N_synth_data_sig
	.N_synth_in_data(N_synth_in_data),  // input [7:0] N_synth_data_sig
	.N_save_sig (N_save_sig),   //output
	.N_load_sig (N_load_sig),   //output
	.N_sound_nr (N_sound_nr),   //output
`endif
	.AUD_ADCLRCK			( AUD_ADCLRCK),      //  Audio CODEC ADC LR Clock
	.AUD_DACLRCK			( AUD_DACLRCK),      //  Audio CODEC DAC LR Clock
	.AUD_ADCDAT				( AUD_ADCDAT ),      //  Audio CODEC ADC Data
	.AUD_DACDAT				( AUD_DACDAT ),      //  Audio CODEC DAC Data
	.AUD_BCLK				( AUD_BCLK   ),      //  Audio CODEC Bit-Stream Clock
	.AUD_XCK					( AUD_XCK    ),      //  Audio CODEC Chip Clock
/*	.data					(data),
	.cpu_adr				(cpu_adr),
	.reg_read_write_act	(reg_read_write_act),
	.cpu_env_sel		( cpu_env_sel ),
	.cpu_osc_sel		( cpu_osc_sel ),
	.cpu_m1_sel			( cpu_m1_sel ),
	.cpu_m2_sel			( cpu_m2_sel ),
	.cpu_com_sel		( cpu_com_sel ),
	.cpu_read			(cpu_read),
	.cpu_write			(cpu_write),
	.cpu_chip_sel		(cpu_chip_sel),
*/
	.data					(),
	.cpu_adr				(7'b0),
	.reg_read_write_act	(),
	.cpu_env_sel		( 1'b0 ),
	.cpu_osc_sel		( 1'b0 ),
	.cpu_m1_sel			( 1'b0 ),
	.cpu_m2_sel			( 1'b0 ),
	.cpu_com_sel		( 1'b0 ),
	.cpu_read			( 1'b0 ),
	.cpu_write			( 1'b0 ),
	.cpu_chip_sel		( 1'b0 )
);


/////////////////////////////////////////////////////////////////////
// I2C //



always @(negedge KEY[3] or posedge CLOCK_50) 
    begin
        if ( !KEY[3])
            delay_1 <=0 ;
        else if ( !delay_1 [7] )
            delay_1 <= delay_1 + 1'b1;
    end

I2C_AV_Config       u3  (   //  Host Side
                            .iCLK  ( CLOCK_50    ),
                            .iRST_N( delay_1[7] ),
                            //  I2C Side
                            .I2C_SCLK(I2C_SCLK),
                            .I2C_SDAT(I2C_SDAT) 
                            
                            );


endmodule
